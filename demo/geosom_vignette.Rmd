---
title: "geosom: An implementation of spatially-aware Self-Organising Maps in R"
author: "Andre Kotze"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
The Self-Organising Map (SOM) is a type of Artificial Neural Network (ANN) first proposed by Finnish scientist Teuvo Kohonen in 1982. It's main uses are in data clustering and dimensionality reduction. Features with any number of attributes are projected onto a lower-dimensional neural network (commonly 1-, 2- or 3-dimensional) for the purpose of simplification, visualisation or pattern analysis. In order to improve it's usefulness for spatial data science, the SOM can be modified to consider geographic proximity during it's learning. The result is clustering that is geographically coherent and can provide additional insights into the source data.

The spatially aware SOM (GeoSOM) was developed at the New University of Lisbon (UNL) in the early 2000s and a software suite was created in MATLAB. The software installer requires Windows and the source code consists of MATLAB .m files. Thus, a free and open-source implementation is currently not available to researchers or the public.

# Background


# Sample Data
Example data has been created for the GeoSOM Suite to demonstrate the capabilities of the MATLAB-based GeoSOM software developed at UNL. Available at [GeoSOM Repository](https://www.isegi.unl.pt/labnt/geosom/georepository/) (Lobo, 2009), two of the datasets are included here. Both datasets have a single non-spatial attribute, such that clustering would depend entirely on this property in the traditional SOM. Using the GeoSOM, however, we expect the clustering to also be partially spatially dictated.

## Squareville
*Squareville is an artificial dataset purposely created to use in GeoSOM suite. Squareville is a small-town with square boundaries and an area of 10000 m2.  Squareville has 100 houses evenly spaced with coordinates x in [5, 95] and y in [5, 95]. For each house we know the average salary, which is s in  [900 1000] for 35≤x≤65 and s in [0 100] *
This simple scenario consists of 100 houses in a regular grid. Roughly divided into thirds, the first and last third have significantly lower values for "average salary" than the middle third. Traditional clustering simply yields two clusters, for rich and poor (high and low values). Incorporating a geographic constraint, we expect the poor cluster to differentiate into an "eastern" and a "western" poor area.

## 4 Corners
*The points follow a uniform distribution in the geographical coordinate, within the rectangle limited by [(0,0),(20,5)]. In the non-geographical dimension there are three zones of high spatial autocorrelation, where the values of z are very similar among neighbouring points, with a uniform in [90,91] in two zones and [10,11] in another. There is also one area of "negative autocorrelation", where half the data points have z==0 and the other half have z==90. In the rest of the input space z has a uniform distribution in [0,100]. *
This feature space has 5000 points in a regular grid, with five distinct zones (also based on a single non-spatial attribute). Simple SOM clustering would group these points according to value only, whereas we would expect the GeoSOM to create geographically separate clusters in the four corners as well as (depending on the model parameterisation) within the one corner with high negative autocorrelation.

# Methodology
The GeoSOM takes an additional parameter *k*, which can be defined as the spatial weight. With *k=0* space is disregarded and the GeoSOM functions exactly as a traditional SOM. As the value of *k* tends towards the map size, spatial proximity increases in significance. To incorporate this constraint, neurons are filtered by proximity during every learning iteration *i.e.* the best matching unit (BMU) can only be selected from a proximal subset of all the neurons in the map. Thus, with a single feature selected, the geographic distance to every neuron is calculated and distal neurons are excluded from consideration. Then the vector distances in the feature space are calculated (as per the normal routine) and the BMU selected. The rest of the learning process is identical to a conventional SOM.

For demonstration and consistency, a rectangular grid of 4x5 neurons

The routine in question is actually an included Rcpp function. The function is defined in ```src/distance-functions.cpp``` (in package "kohonen") starting at line 201. We will create an entirely separate package (named "geosom") with the modified function, but with all file names unchanged.

### Current limitation: if X and Y column included, the program operates as a geosom    NOT ANYMORE
Current limitation: meridian-crossing
```{Rcpp}
/*
 * Finds the best matching codebook unit for the given data object and stores
 * its index and distance in the specified nearest unit index and nearest unit
 * distance references.
 */
void FindBestMatchingUnit(
  double *object,
  double *codes,
  int *offsets,
  int *numNAs,
  int numCodes,
  int numLayers,
  int *numVars,
  int totalVars,
  const std::vector<DistanceFunctionPtr> &distanceFunctions,
  double *weights,
  int &index,
  double &distance) {
  int nind = 1;
  double dist;

  index = NA_INTEGER;
  distance = DBL_MAX;
  for (int cd = 0; cd < numCodes; ++cd) {

    /* Calculate current unit distance */
    dist = 0.0;
    for (int l = 0; l < numLayers; ++l) {
      dist += weights[l] * (*distanceFunctions[l])(
        &object[offsets[l]],
        &codes[cd * totalVars + offsets[l]],
        numVars[l],
        numNAs[l]);
    }

    /* Update best matching unit */
    if (dist <= distance * (1 + EPS)) {
      if (dist < distance * (1 - EPS)) {
        nind = 1;
        index = cd;
      } else {
        if (++nind * UNIF < 1.0) {
          index = cd;
        }
      }
      distance = dist;
    }
  }
  
  if (distance == DBL_MAX) {
    distance = NA_REAL;
    index = NA_INTEGER;
  }
}
```


## Initialisation
```{r}
library(kohonen)
library(Rcpp)
library(sf)
library(ggplot2)
```

## Parameter Definition
```{r}
# Using the same parameters for control
k = 0.5                   # spatial weight
som_x = 5                 # neural map horizontal size
som_y = 4                 # neural map vertical size
l_rate = c(0.05, 0.01)    # learning rate
n_radius = 1              # neighbourhood radius
train_iter = 100         # number of training iterations
norm = TRUE             # normalise input data

set.seed(151)
som.grid = somgrid(
    xdim = som_x, 
    ydim = som_y, 
    topo = 'hexagonal', 
    neighbourhood.fct = 'gaussian')      # neural map grid
```


## The geosom class/function
```{r}
# subclass som
```


# Results

```{r}
# plot function 3 x 2
show_results = function(som_model) {
par(mfrow = c(2, 3))

plot_types = c("mapping", "counts", "property", "codes", "dist.neighbours", "changes")
for (plot_type in plot_types) {
  if (plot_type != "property") {
    plot(som_model, type = plot_type, shape="straight")}
  else {
    plot(som_model, type = plot_type, property = getCodes(som_model)[, 1], shape="straight")
  }
}

}
```




## Squareville
```{r}
# Data
squareville_data = read.csv("data/squareville.csv", sep=";")
squareville_data = squareville_data[,1:3]
```

```{r}
# Conventional SOM:
square = squareville_data$S
if (norm){
  square = scale(square)
}

#som.grid = somgrid(8, 6, "hexagonal", "gaussian")
som.model = som(data.matrix(square), grid = som.grid)

show_results(som.model)
```

```{r}
# GeoSOM:
geo_x = 'X'
geo_y = 'Y'

som.model = geosom(data.matrix(square), grid = som.grid, mode= "online", x_coord = "X", y_coord = "Y", geo_weight = k)
```




## 4 Corners
```{r}
# Data
corners = read.csv("data/4corners.csv", sep=",")
# Conventional SOM:
som.model = som(data.matrix(corners$L), grid = som.grid)
show_results(som.model)
# GeoSOM:
geo_x = 'X'
geo_y = 'Y'


```


# Discussion

# Conclusion

# References

Bação, F., Lobo, V. and Painho, M., 2004, October. Geo-self-organizing map (Geo-SOM) for building and exploring homogeneous regions. In *International Conference on Geographic Information Science* (pp. 22-37). Springer, Berlin, Heidelberg.

Bação, F., Lobo, V. and Painho, M., 2005. The self-organizing map, the Geo-SOM, and relevant variants for geosciences. *Computers & geosciences*, 31(2), pp.155-163.

Henriques, R., Bação, F. and Lobo, V., 2009, June. GeoSOM Suite: A tool for spatial clustering. In *International conference on computational science and its applications* (pp. 453-466). Springer, Berlin, Heidelberg.

Henriques, R., Bacao, F. and Lobo, V., 2010, February. Spatial Clustering with SOM and GeoSOM: Case Study of Lisbon's Metropolitan Area. In *2010 Second International Conference on Advanced Geographic Information Systems, Applications, and Services* (pp. 148-152). IEEE.

Henriques, R., Bacao, F. and Lobo, V., 2012. Exploratory geospatial data analysis using the GeoSOM suite. *Computers, Environment and Urban Systems*, 36(3), pp.218-232.

Kohonen, T., 1990. The self-organizing map. *Proceedings of the IEEE*, 78(9), pp.1464-1480.

Kohonen, T., 2001. Learning vector quantization. In *Self-organizing maps* (pp. 245-261). Springer, Berlin, Heidelberg.

Lobo, V., 2009, March. GeoSOM Repository, viewed 4 September 2022, <https://www.isegi.unl.pt/labnt/geosom/georepository/>.

Wehrens R, Kruisselbrink J (2018). “Flexible Self-Organizing Maps in kohonen 3.0.” _Journal of Statistical Software_, *87*(7),
1-18. doi: 10.18637/jss.v087.i07 (URL: https://doi.org/10.18637/jss.v087.i07).

Wehrens R, Buydens LMC (2007). “Self- and Super-Organizing Maps in R: The kohonen Package.” _Journal of Statistical Software_,
*21*(5), 1-19. doi: 10.18637/jss.v021.i05 (URL: https://doi.org/10.18637/jss.v021.i05).
